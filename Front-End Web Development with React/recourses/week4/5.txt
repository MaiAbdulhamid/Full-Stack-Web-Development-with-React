Now, that we have learnt about Redux middleware and Redux Thunk, in this exercise let's employ the Redux middleware, a logger middleware, and see how we can log all the changes that we caused to the Redux store into our console. And also, we will use the Redux Thunk to return a function, and then see how we can make use of it to carry out actions. To get started of this exercise, let's first install Redux Thunk and Redux Logger into our project. So, at the prompt, type, "yarn add redux-thunk@2.2.0". You can also do Npm install as I have always been mentioning. And then, let's install redux-logger@3.0.6. Now, once we have installed both the Thunk and Logger, let's not go and update our application to apply these to middleware. Going to our project in the configureStore.js file, we will apply the middleware, the Thunk and the Logger. So, open the configureStore.js file and then import applyMiddleware from Redux, and also import Thunk from redux-thunk, and Logger from redux-logger. Now that we have these two middleware available to us, let's apply these two to our store. So, to do that, we'll go into the createStore here. The createStore takes an enhancer as the second parameter here. So, since they're applyMiddleware will return in store enhancer. So, we'll say, applyMiddleware there and then say, "thunk, logger." So, both of these are being supplied into our store as enhancers for our store. And once we do that, then both the Thunk and the Logger become available within our application. Now, we will introduce a few additional action types into our application. Now here, I will demonstrate the use of a Redux Thunk by showing you an example without requiring an asynchronous API call. But then, after the next lesson, we'll come back to introduce communication with a server where I will again modify this Thunk to allow us to communicate with a server. Now, before we do that, let's go to action types. In ActionTypes.js, let me add in a few more action types. I will say, export dishes loading as DISHES_LOADING, and dishes failed as DISHES_FAILED, and then add dishes as ADD_DISHES. Now, from the names itself, you can begin to guess what the intention of these action types are. The DISHES_LOADING means that the dishes are currently being fetched, perhaps from a server. The dishes information has been fetched from a server. The DISHES_FAILED means that you failed to fetch the dishes information from a server, and then ADD_DISHES means that you want to add the dishes into your store. So, that's the intention of these three actions here. So, once we have introduced these action types, let's open ActionCreators.js. And then in here, we will introduce the first Thunk into place here. Now, in here, what I'm going to do is I'm also going to open the dishes.js file, and I'm going to remove this from the dishes.js file. We will no longer need it there, because I'll make this the responsibility of the action creator to supply that information to my dishes reducer. So, I'm going to put it into place here. So, I've cut this from dishes.js and then moved it into the ActionCreators.js file here. Now, let me introduce more functions here. So we'll say, export const fetchDishes. And as you would expect, the fetchDishes should be used for fetching the dishes from wherever you are supposed to. Now, we're going to create this as a Thunk. So, that's why it is going to return a function. So, that's the reason why I define that as an arrow function there. Inside that, there will be another arrow function. So, you see that this is a returning a function from here, an arrow function in here. So, this is the function that is going to be returned. This is creating this particular function here and this function is going to be returned by this, and this function, as you see, the inner function gets access to the dispatch, and also get state if you require. But right now in this example, I'm only going to make use of the dispatch and so we will define the inner function in here. So, you can see that this is going to be a Thunk here, because it is returning a function, which is containing an inner function in here. So, what does this do? So, first, it says, dispatch dishesLoading with true here. Now, what does that mean? We'll come to that point in a short while. And then after that, I'm going to introduce a short delay. I'm just going to take the help of the setTimeout function here to introduce that delay there. Later on, we will replace this with an asynchronous call to a server there. So, the setTimeout is going to supply a function with a delay of 2000 milliseconds, so that's what it is going to cost. Now, inside the setTimeout, what am I going to do? After a 2000-second delay, I will dispatch a call to another function called addDishes with the dishes that I have imported here. So, those dishes object will be supplied to the addDishes here. So, as you can see, this Thunk is doing two dispatches. First, it does the first dispatch. We'll see what does dishesLoading is going to do in a short while. And then, after two seconds delay, it's going to dispatch the addDishes. So, this is going to push the dishes into the state of our store there. Now, let me implement that next function which is, dishesLoading. What does dishesLoading do? So, this is a function which returns, as you would expect, an action here. What kind of an action is it going to return? It's going to return an action of the type ActionTypes.DISHES_LOADING. That's the action that it was going to return. Now, note that in this case, it doesn't have any more data associated with it. It is going to only return a type here. Now, based upon how we implement the dishes reducer that will be able to interpret what this action is going to do. Now, intuitively, you might have already guessed that this is going to inform somebody saying that the dishes are beginning to be loaded and so you need to wait for the dishes to be loaded. So, that's the interpretation that we're going to give to this function here. Now, again, also I will implement another function called dishesFailed, and this dishesFailed will take an error message as a parameter. So, this is again a function as you expect, which is going to return an action object. So, it'll return an action object of the type, ActionTypes.DISHES_FAILED, and also it will return a payload as error message. Now, in this case, this error message is going to be a string, but the implementation here doesn't really tell you what the error message is. Whatever we pass into the dishesFailed object, that will be delivered as a payload to the dishes reducer, and so we will make use of it there. Now, when you fix the reducer then you'll begin to see how we, by the way, interpreting all these different things there. Now, so, your dishes failed. And then also, you have this addDishes that I need to implement. So, how do I add dishes? So that will also be a function that returns an action. And what kind of an action? You'd have already guessed that by now. Note that the addDishes is taking all the dish information as a parameter here, so it must be creating an action of the type, dishes ADD_DISHES action type, and then it'll pass the dishes as the payload or the second part of my action object here. Let's check. So, we have now set up all the action creators here, four different action creator functions here. Three of them are returning an action object, the dishesLoading, distanceFailed and addDishes, and then the fourth one, the fetchDishes is a count that is returning a function that is going to call or dispatch several actions. Now, that we have fixed up the action types, we need to interpret these three different action types and as you would expect, these three different action types are going to affect only the dishes part of the state of our application. So, that action should all be in the dishes.js file. So, going in to the dishes.js file, let me import the action types here. So, I'm going to copy this action types from the actual creators and then import that into the dishes here. Now, since we already have the switch statement, so I should be able to now switch between the three different action types that I'm going to receive here. So, let me set up the three action types here. So, we'll say case ActionTypes.ADD_DISHES, so that is one of them. Then we'll have a case ActionTypes then DISHES_LOADING and also, a case for ActionTypes.DISHES_FAILED. So, three different actions need to be interpreted by this reducers function here. So, it's supposed to do something in response to receiving these three actions. So, it's the responsibility of this dishes reducer to interpret what these actions mean. Now, let me come in here. What I am going to do is I'm going to change the shape of my state here. My state will no longer be just dishes here, dishes is not available anywhere here. So, I'm going to change the state to have three different parameters here. So, I'm going to retype this as follows. So, this state here will have three different parameters. So, it will say, isLoading, which we'll initially set to true, and then a second parameter code error message which will be initially set to null, and then a code parameter, dishes, which will be initially set equal to an empty array. So, now you see that my state has been extended to contain three properties here. The isLoading property, the error message property, and the dishes property. Now, how do we interpret this? Initially, the isLoading property is true because the dishes is empty here. So, that means that you'll need to load the dishes' information from somewhere before the details of the dishes become available within your state. The error message, it will be set to equal to the error message that will be passed in when you receive the DISHES_FAILED action here, otherwise, it will be null. So, if you try to fetch the dishes from a server and the server fails to deliver the dishes to you, then you will set the error message to the corresponding error message that has been returned to you from the server. Otherwise, if the dishes are obtained correctly, then the dishes will be loaded in with the information about the dishes. Now, that will be done when you receive the ADD_DISHES action here. So now, you see the three kinds of actions that we have seen here. DISHES_LOADING, DISHES_FAILED, and then ADD_DISHES. Now, what do we do in each of these three cases? Initially, because we don't have the dishes information, I'm going to set the isLoading to true. But then the moment you call the ADD_DISHES, then isLoading should be set equal to false because the dishes will be loaded in. When you call the DISHES_LOADING, if it was originally false set to true meaning that you're beginning to fetch new dishes. So, this way, whenever you go to the server to fetch the dish information from the server, you can set the isLoading to true. Once you obtain the dishes information from the server, you set the isLoading to false and then load in the dishes into the dishes property of this part of the state. So now, you see that your state shape has changed a little bit, and within the state, I am tracking three pieces of information within the part of the state that corresponds to the dishes. So, that's the change that we have done here. Now, let me start with the DISHES_LOADING. So, when you receive an action saying DISHES_LOADING, an action of the type DISHES_LOADING, what do you do? You will return, now, this is where I'm going to use this sprint operator from ES6. So, that means that this state, that whatever the state is, I'm just going to take the same state and then I can add, and so this is the sprint operator that I'm going to load in here. So, it will take the current value of the state and then whatever else that I passing in after this will be applied as modifications to the state. So again, the state itself will not be mutated, instead, I take the state, I create a new object from the original state and then make some changes to that object and then return that object. So that's why I am returning an immutable from here. So, the state itself is not going to be mutated here. So, if I receive the DISHES_LOADING action, then that means that I'm beginning to load the dishes. So, at this point, I'm going to set the isLoading to true and then the error message will be left as null and the dishes also will be null at this point. Now, you might say, why would we need to do these two. Maybe in between, you're refreshing the information from the server. So at that point, you will want to do it this way. You said that isLoading to two and the remaining two, you will set to null and the dishes to an empty object here. That is what you're going to be returning when you receive a DISHES_LOADING action time. Now, look at the structure of how I am organizing the reducer here for the dishes part of the state. You will do a similar thing for both the promotions, the leaders, and the comments also when you're required to do that. Now, if the dishes failed to load, what do you need to do? Now, as you realize the dishes failed to load, then the payload in that call, and the action.payload will contain the error message. So in that case, I'm going to return the original state, the sprint operator. I will set the isLoading to false because I have already failed to load the dishes, so I need to set up the error message. So, the error message will be equal to action.payload. Then I will set the dishes to an empty array anyway because I don't have any dishes here. So, by doing this, what we are specifying is that their dishes have tried to be loaded but it failed. This is the corresponding error message that I've received, so that is what I'm going to be setting the error message. Now, by doing this, when your state is set up like that, when your React Component retrieves the state, it can then interpret this information accordingly and then display this information in the view, as per what the state contains. Again, we will modify the view in a short while and then you will see how we make use of this. Now, the third case, if I have actually returned the dishes object, what am I supposed to do? Now, here, let me just copy this here because the structure would be similar here. So, when the ADD_DISHES action is current, then in that case, I'm going to take the original state. I'm going to set the East loading to false. The error message will be set equal to null. But recall that the action.payload carries the dishes information. So in this case, I will set the dishes to action.payload. So, that's the change that I'm going to make here. So, when the ADD_DISHES action is passed into this reducer, then whatever is passed in as the parameter there in the payload of the action object, that will be set equal to that dishes there. So now again, going back to the action creator, you see when you create the action here, for the ADD_DISHES type, your payload is carrying the dishes there. So, that's what is retrieved in the dishes reducer here and then the dishes property is set equal to that thing. So, with this, we have updated the dishes.js file here and so, we have updated the reducer corresponding to the dishes state. Now, how do we make use of this state in our React Application itself? So far, we have been only tinkering with the redux part of overapplication. Now, we will go into the React part of our application and then see how we can make use of this. Now, first and foremost, if the isLoading is set to true, I may just want to display a loading spinner on the screen just to keep the user informed about the fact that something is being loaded from somewhere. So, to do that, I'm going to create a new component in my application called as the loading component. Now, this loading component, I'm going to make use of it whenever I require this. Now, so I will create the loading component by importing React from React, and then I will create this as from the structure, so if you should have guessed that, this is a functional component that I am creating. So, this is going to return this arrow function here. So, what am I turning in this arrow function? Very simple, we'll return. A loading spinner information here. How do you create a loading spinner here? So, we'll say div class name col 12, and inside this div I'm going to use the font awesome which provides a spinnash icon, fa spinner icon. And then if I apply the pulse font awesome class to that, then that will make the spinner rotate around. That's the intention of this. And then fa three times the speed and then say fa forward spinning and then text primaries so the color of this spinner is going to be primary color, and then close the span. So, this will create a rotating spinnash on the screen. Now, then we actually make use of this, then you will see what the spinner looks like and how it rotates around. And also in addition to this, I am going to display a small message saying, "Loading." I am sure you have seen this kind of loading messages on many websites, on many mobile applications. So, that's the loading component which displays this loading message on the screen which I have just created. So, now, that we have created, how do we make use of these loading component? So, to do that we need to go into our main component, going into the main component. Now, let me again go back to the action creators and then draw your attention to this fetchDishes. The fetchDishes as you see is a punk which returns a function which when called will try to fetch the dishes first by setting the isLoading to "True", and so that the spinner can be displayed and after a period of time the dishes are fetched and then added into the application. So, that is what this fetchDishes is going to show for us. So, how do we make use of this in the main component? So, going into the main component, in addition to the "Add comment" I'm going to also "Add in the fetchDishes" from the redux action creators. Now the fetchDishes, I will map it into my props here so in the mapDispatchToProps, I'm going to create a new property called as fetchDishes which when invoked will result in a call to dispatch fetchDishes function that I have just imported here. So, what is this doing? The call, this is a punk, and so we can dispatch that punk by using dispatch and in order to do the dispatch, I need to map it in the DispatchToProp so that dispatch dishes becomes available for my main component to make use of. So, in the main component I need to fetch the dishes. So, where do I fetch the dishes? So, this is where I can take the help of the lifecycle method of my component called as componentDidMount. Now, this lifecycle method, whatever we include in this lifecycle method component will bound will be called or will be executed just after this component gets mounted into the view of my application. So, right at the point this would be called. That is a very good time for me to fetch any data that I require for my application. So, that is exactly where I'm going to call the fetchDishes that I just mapped in here, this fetchDishes. So, I'm going to call it index. So, what will happen is that when the main component is being mounted into my view by my the act application. At the point after it gets mounted the fetchDishes will be called and this will result in a call to fetch the dishes and then load it into my redux's store at the point, and then when that becomes available, then it'll become available for my application. So, that's the process by which I'm going to make this available to my application. So, you see how much of dependency that goes into this. Now, coming down to the homepage here, in the home page, now, the dish information itself will no longer be at this props dot dishes. Now if you recall, the state dot dishes is mapped to dishes, but the state dot dishes, the shape of those dishes object has changed because when you go into the dishes reducer, the dishes object itself is now containing three properties here "isLoading" a real message and dishes. So, if you need to get information about all the dishes then that will be available in dishes dot dishes in here. And then similarly, dishes dot isLoading, if it is true that means that the information is being loaded here. So, that's something that we need to recognize at this point, so when you parsing the dish information to the home component, then you say, "This props dot dishes dot dishes." So, that is what we are going to be using to get access to the dishes and from there you will fetch and then map the first one and then parse that in into my home component. Not only that, you need to remember that there is one more flag or property that I need to parse in called as "DishesLoading." So, one more attribute that I'm going to parse in called dishesLoading, and I'm going to make use of this in my home component. So, I will say, dishesLoading and then this will say, "This props dishes isLoading." So, that is what will be parsed in as the second property here. And then also, we need to recognize that it is possible that the dishes fetching may fail, and so the error message may be set there. So, I will also parse in error message from the dishes. Now, the reason I am marking this separately as dish, dishesLoading and dishesErrorMessage is that the same thing will also apply for a promotion and leader also later on, so that's why I'm separating them out into three different things here. So, from the home that is what I'm going to parse in. Similarly for the DishDetail here, I'm going to parse in "This props dot dishes dot dishes." "The isLoading an errorMessage" also have to be parsed into the DishDetail component, so I'm going to come into the DishDetail component also and modify this. Now, for the DishDetail component, since I'm only going to be parsing in the dish and nothing else, I can simply call this as "isLoading" and then simply call this as "ErrorMessage." That's perfectly acceptable here. Dish isLoading and errorMessage here. So, that's how I'm parsing in this information into the dish isLoading. Now, within my dishes isLoading or within my DishDetail component, so this will result in a modification to the DishDetail component. So, when I come into the DishDetail component, I realized that in the detail component it's possible that when I come in, the props dot dish maybe null, and so, I may not be able to display the dish at all. So, in that case what am I supposed to do? So, that is why when you come in here into the DishDetail component we will say here, we will import the LoadingComponent from the LoadingComponent here, because we are going to be making use of the Loading Component in here. So, in the DishDetail component, what I am going to do is we will start all by saying, "if props is loaded, if props isLoading", if that is true. So, you see the order in which I am examining. If the isLoading property, recall how we are parsing the isLoading from the main component, So, in the main component we are setting the isLoading to the flag from props dishes isLoading. So, in the DishDetail component we are saying, "If props isLoading, then we will return." So you see that we are doing conditional rendering here. Conditioned on certain properties here. So this here we'll say div class name container and inside those div, what I'm going to do is div class name row. Remember we need to do this container row in all the business for this also because you need to properly position that on the screen using a bootstrap grid and then we will see the loading component. We just imported the loading component here. So if the isloading is true then I'm going to just simply return the view as the loading component. So the loading spinner will be shown on the screen. Now the second part we'll say else if props error message. So if it is an error message that is going to be shown here, then what do I return? So if it is an error message then I will return, then we copy this and then modify that here. I'll return container row and then in here I will say will not display the loading message. Instead I will say h4props.errMess. So I'm just going to display the error message there. That's about it. Otherwise, of course that last else says that my div is not null. The error message is null and the loading is false, then I drop into, which means my dish is ready so I should be able to display the dish here, so the rest of the code will remain as such. I'll be able to display that dish here. That's the modification that I'm going to make in my dish detail component. Look at the structure of this code. The same structure I will be making use in many other places where I display the details about the dish here. Now the dish information is displayed in three different components, the dish detail component, the menu component, and the home component. Totally different places where I will have access to the dish detail component. So I will have to rely on the information about the dishes. So the next thing that I'm going to fix is the home components. So going into the home component. In the home component now I'm going to fix up this render card by saying item is loading error message. So three things that I will display here. So here, I will say item is loading error message for the dishes. So recall that we had props.dish which is being supplied here. The two other things that came in as parameters here. So that I will pass in as the error message. So I'll say, isLoading equal to props.dishesLoading. Recall that from my main component, I'm passing in dishes loading and dishes error message here. So these two also need to be passed into my render card component there. So I will say is loadings. So for the sake of platitude of reading I will put that into the next line here, and then the next one says error message is props.dishesErrMess. Did I say dishesErrMess? Yes, I said dishesErrMess here. So I will say dishesErrMess. So that's it. So I'm passing in these two also as parameters here. For the remaining two, we'll fix that up later when we have those also operating using the same approach that I use for dishes. I'm demonstrating to you how we do it for dishes but the other ones I will probably leave that as an exercise for you in one of the later exercises or in the assignment. So we'll look at those later. Now within the card, when you display the card, you'll realize that now you're going to be receiving three item, isloading, and error message. So in here, we're going to be fixing up this by saying in the render card, they'll say if isloading, we will return loading from here. Now if I need to return loading I need to import loading from loading component. Right? Now so if isloading, else if error message. So this would be a generic structure that we will do here else error message, if error message, return. Now in this case, the row and column and the other part is already taken care of by my home components layout so that's why I don't need to surround these with the divs, with the container and row here. So I can just simply pass this directly here. So if the error message is not now then I will post the error message in here. Otherwise, I will return the spot here. Let me indent this here. So I will return, else. The else part will cause me to return the layout of the card as such. So that's how we'll fix up the home component. The last one left to fix is the menu component. Going to the menu component. In the menu component, when I come in here, I will be receiving the... So going to the main component, let's see how the information about the dishes being passed into them menu component. So going into the home component for the menu component, you'll see that I'm saying dishes says this props dishes, so the entire dishes object is being passed in there. So I will have dishes isloading, dishes.dishes, dishes.ErrMess all three available to be here. So in the menu component, I need to fix up the be rendered the menu component here. So how do I fix that up? So in here, we'll say const. So again, first thing first. I need to import the loading component from the loading component. That's the first thing that I need to do, and then here when I render the menu this will be props.dishes.dishes, not props.dishes. So I need to update that. Then here I will change this to sync. If props.dishes.isLoading. So if the dishes is being loaded, then I need to return the loading. So, let me go to the dish detail component and then simply copy this part here, because that would be useful for me as a way of saving myself the trouble of having to type the whole thing there. So, let me paste the code in here and then we'll fix this up. So if the props.dishes.isLoading is true, then I will return the loading. If props.dishes.error message is true, then I will return props.dishes.error message. So, remember to fix the code correctly when you copy also. So that's very important, otherwise you'll end up with a problem in the way your application is running, and you'll be chasing around trying to figure out where the thing has gone wrong. If none of these are true, then I will return then layout as I show here below. Let me just indent this for ease of reading. So otherwise, I will return the actual layout of my menu as shown here. That's it. So we have fixed up all the components to enable us to take care of the fact that the dish loading will take some time. Now, let's save the changes and then go and take a look at our application in the browser. Going to the browser, it seems that my application has already gotten loaded. Let me just try to refresh this and then you will see how this works. So when I refresh it, you will initially see the loading on the dishes before the actual dish information is loaded onto the screen here. So that is what the loading component is doing there. Similarly, if I go to the menu component because the dishes have been fetched already, so the menu component will render without any problem. But suppose I refresh my application, you will see the loading being displayed there before the actual menu items are displayed there. Similarly, let me go to a specific dish and then again, I'll reload my application. So then I reload my application. You will see the loading spinner being shown initially before the information about the dishes are shown on the screen there. Now once the dish information is fetched, then my application will display the information just like before, so there'll be no change there. Now, the other part that I haven't discussed is the middleware, the logger middleware that we have put into our application. How does the logger middleware work? Now to see the logger middleware's operation in your browser, open your JavaScript console of your browser. If you are using Chrome, that's where you find the JavaScript console. If you're using another browser, look for it in the developer tools. Now going into that, again, I'm extending this so that you can see what has been printed in the console here. So in the console, what does the logger do? The logger prints out all the various actions that are dispatched and also as you can see, it shows the previous state, the action and the next state. So this is a good way of watching out to see if your application is doing exactly what it is expected to do. So as you can see, initially when my application got loaded, I dispatched the dishes loading action there that this dishes loading action was dispatched by a call to the fetch dishes. In here, look at the previous state. When I open the previous state, you can see that the comments are there, the leaders are there, the promotions are there, but look at the dishes part of the state there. In the dishes part isLoading is true, error message is null, and the dishes itself is an empty array here. So that's what it shows here. Now, when the dishes loading is called. So this is the action that has been sent, the dishes loading action. When it is called, you can see that there's no change in the state here because still isLoading is true initially, but then look at the ADD_DISHES. When the ADD_DISHES is called, the previous state is isLoading true and so on. But then, what does the action carry? The action itself carries the ADD_DISHES type, and the payload here carries the information about all the four dishes. They have just passed this information in through the action and then your store will update the dishes arrays. So you see that the dishes part of the state has now been updated. Note, that the isLoading is false now because the dishes now is an array of four objects. As you see, we have four dishes in our application, so the four dishes have been loaded. You can open this and then see the four dishes in here. This was exactly what was passed in as the payload for my object here. So that is your Redux Thunk and your Redux Logger in action. So as I said, the Redux Logger will enable you to trace your application as it is executing things. So as the different actions are being dispatched to your Redux Store, all that would be logged in the console here. So that is if your application is not doing what you expect it to do. This is a place where you can debug to see if the state changes are happening correctly or not. So, that's the use of the logger that we have seen earlier. So with this long exercise, we have completed integrating the Redux Thunk and the Redux Logger into our application. We have created our first Thunk, and then we have seen how we can set up our application to be able to quote, unquote 'asynchronously' loading information into our Redux Store through the Thunk, and how we can display a loading message on the screen while this loading is happening. This is a good time for you to do a Git commit with the message, Redux Thunk.