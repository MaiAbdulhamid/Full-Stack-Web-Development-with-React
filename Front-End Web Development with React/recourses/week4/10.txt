Asynchronous computation is all over the place in the World Wide Web and how the web operates. If you are coming from the sequential programming world wrapping your head around asynchronous computation takes quite a bit of effort. There have been many attempts at making asynchronous computation as painless as possible for people transitioning into it from the sequential computation, but one such attempt is promises. As we realized when we make any request to a backend server, it is going to take some time for the results to become available. If we do such a request while we are proceeding with our work, then, there is a high likelihood that our computation will get stuck at the point waiting from the results. This is a no no in terms of a good user experience. So, it is important that whenever your results are going to take time you should be able to proceed forward without waiting for the result. Promises provide us with a way of dealing with this. Let's look at promises in a little more detail in this lecture. Promises the general concept is a very vast area by itself, and in this course I don't have time to go through the details of promises. That will become an entire course in itself. I will give you just the essentials of promises that are necessary for us to understand how to make use of promises within our application. I do provide you with a lot of leads to additional resources where you can go and examine promises in more detail. So, coming down to that question, what exactly is a promise? A promise is a mechanism that supports asynchronous computation. I just gave a long-winded explanation of why asynchronous computation is essential for the web to function. Now, in using a promise, the promise provides a mechanism or a proxy for a value that is not available at the moment that you asked for it. So a promise will return a promise to you saying that when the result becomes available it'll come back and deliver the results to you. So, a promise returns a proxy object to you and you hold onto the proxy object and that proxy object will give you access to the results when they become available. There is a method in how you wait for the results. You actually don't suspend your computation at that point instead, you configure a way of accepting the results when it comes back from the promise. To put it in a nutshell, promise represents a value that would be available at a future time. It may be also immediately available in which case the promise will return the value immediately. But in case it needs to return a value at a future date then it gives you the promise that that value when it becomes available, will be returned to you. There's always the possibility that the promise cannot be met because the results are unavailable for whatever reason. In that case, an error will be delivered to you, or a reject will be delivered to you and it is up to you to deal with the fact that the promise was rejected. We'll look at how we will deal with that in the next slide. As we learned earlier, a promise is a proxy for something that is going to happen in the future or may never happen in the future. So, a promise when it is given to you will be in the pending state. Now, when the promise resolves, that is the results become available and the promise is able to deliver the results to you, then the promise will resolve or will fulfill. In that case, the promise will move from the pending state to that resolved or the fulfilled state. So at that point, your results are available to you. There is a slight chance that the promise may be rejected because of an error or whatever be the reason. In that remote circumstance you would be delivered a reject and in that case, the promise will be considered to be in the rejected state rendered reject as deliberate. So, when you generate a promise, as I said, a promise isn't a proxy object that is delivered to you. So when you deliver a promise to somebody the promise internally will have a function that will deal with both the resolve and the reject options inside there. Then you write code. You will see that you'll write code as new Promise (function (resolve, reject). So, whether it resolves or it gets rejected we need to be able to send back the information to whoever we delivered the promise to. How do we do this in code? Let's take a look at that in the next slide. Here's an example of how promise is configured in code. Indeed, this example is derived from the exercise that you will do a little bit later. So, when the promise is returned then the return promise is available to you as an object, and this promise provides two methods,.then and the.catch method. Now, then the promise is successfully resolved, then their promise will result in calling a resolve. As you saw the promise is constructed and inside the promise you have the function that resolve and reject as the two parameters. So if the promise is successfully able to deliver the result, then it'll call the resolve method and then return the result to you. Where does the result get delivered to you? When you write code waiting for the promise then you would specify what to do when the promise returns the result in that then option for the promise. If the promise is not able to resolve correctly then it will reject with the error being sent back to you, the error being another object that will be sent back to you. So, when the promise gets rejected, then you deal with that rejection using a "Catch" within your code. So, within the catch you will provide a function that will deal with the error. For example, you may simply output the error message, the console log and deal with the error that way, or you might have a more elaborate way of handling the errors. That will be provided in the catch option that you give for the promise code on your site, when the promise delivers a reject to you. So, this is how the two sides of the coin deal with promises. From one side you're sent the promise object and when you receive the promise object, with the promise object you would either do the then and the catch. So, you're supposed to implement both the then and the catch, methods changed to their promise object. Then from the promise aside if the promise resolves correctly then the result will be called and thereby the result will be delivered in the then method of your promise. If the promise gets rejected, the reject calls will deliver the error into your catch. So, this is how you would implement code using promises. We will deal with the example in the exercise that follows this lecture. Now obviously, the question I ask is, why promises? Later on, when we deal with no geus, we will deal with how we can construct callbacks and I will explain the details of callbacks and the way to deal with callbacks when we cover the no geus in the last course of this specialization. Callbacks have a problem of creating what is referred to as callback hell. So, you have heavily nested callback code that is very complicated to be able to figure out what it is trying to do. Promises provide a way of addressing this callback hell problem. The other advantage of using promises is that promises can be changed. A promise vendor delivers the result in the then you can generate another promise in return and that promise can be dealt with by chaining another then method to that and so on. So, you can chain a set of then methods together to deal with promises one behind other. If the result is immediately available or if you are going to reject immediately then promise provides a method of immediately returning without waiting for their promise to either resolve or reject. In that case, you would simply say promise with the capital P.resolve and promise.reject, and then return either the result or the error immediately. With this quick understanding of promises, let's go on to the next exercise where we will deal with promises.