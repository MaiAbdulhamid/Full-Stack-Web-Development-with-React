Let me start out by giving you a quick 10-minute introduction to the essentials of networking. The more I teach React, the more I realize that just to use the various features of React, you need to have an understanding of so many different connected fields before you can even understand what you're doing with React. But the moment you start chasing each one of these fields, they will become entire courses on their own. And pretty soon, I'll end up teaching the entire Computer Science curriculum to you. But given the fact that we have limited time, I would concentrate on delivering you the essentials that you need for understanding each of the topics. Now, what we cover in this particular module will require at least a rudimentary understanding of how computer networking works before we understand why we need to use HTTP, why we communicate with a server, what is the reason for the delays that ensue when you are talking to a server, and so on. And also, the various protocols that you need to be aware of before you can even communicate with a server. So, keeping all this in mind, a 10-minute quick introduction to the essentials of networking. We begin to realize that web applications are no longer standalone. We always have a, "Cloud" backend supporting your web application. Now these days, everything is on the cloud. Pretty soon, you will be on the cloud, too, at least on cloud nine with a silver lining. But given that we need a server-side support for our React application to work correctly, where would you host the server? And these days, hosting the server is very easily done by using one of the cloud-based infrastructure services, things like the Amazon Web Services or Heroku or DigitalOcean or many others that provide cloud-based server support. So on the server side, what exactly is available on the server side? You typically have a server front-end that is talking to your React application. So that is the server logic, and behind the scenes, the server logic is communicating with a persistent storage like a database where your data is stored and retrieved from. When you enter the networking world, you'll be pretty soon bombarded with 304 little acronyms, things that you thought you knew what they were from normal English but they have an entirely different meaning and purpose when you encounter them in the networking world. So, let's examine a few of them. So in the networking world, you will hear people talking over HTTP protocol, the protocol that is used for communicating between the client and the server. This is an application layer protocol that we will briefly talk about a little more in the rest of this lecture. The HTTP protocol, for it to work, needs a URL to be supplied to it, the Uniform Resource Locator. So this is a string of characters separated by slashes with an http: or an https: attached in front of it. And I'm sure, if you have used the World Wide Web, you are pretty familiar with what the URLs look like. Now in addition, you would hear people talking about JSON, not your friend Jason, but The JavaScript Object Notation. So the JavaScript Object Notation is one way of encoding data that is being shipped from the server side to the client side or vice versa. And also, you will hear people talking about XML, yet another way of encoding data while it is in transit shipment between the client and server side. Now also, you will hear people talking about higher level protocols called SOAP, not the kind that you take a shower with, but SOAP as a protocol that allows communication between distributed entities within the network. And also, you will hear people talking about REST. Not something that you get too much going through this particular course, REST or Representational State Transfer. I will have a shorter lecture specifically devoted to REST a little bit later in this module. And in the HTTP world, you would hear people talking about get, put, post, and delete, and you'd be wondering, what do they all mean? Let's learn a little bit about these in this lecture and also the lecture on REST that you will see a little bit later. One important thing that you need to understand when you are communicating with a server is that the client server communication causes unexpected amount of delays or indeterminate amount of delay while the data is being either fetched or uploaded to the server from the client side. So, which means that within your client side application, you need to keep the user informed over the fact that something is going on behind the scenes and be able to handle the delays and possibly not being able to obtain the data from the server side. It is quite possible that when you try to connect to a server, the connection to the server may fail, the server may return incorrect data or may cause an error in communication. All these have to be handled on your client side appropriately so that your application will still keep functioning even in the presence of these problems. Jumping into the most popular application layer protocol used for communicating between the client and the server, the Hypertext Transfer Protocol. This is a client server communication protocol that may or may not make much sense to you unless you have sufficient background in networking, but this is a protocol that is used for encoding the messages that you exchange between your client application and a server side. So this HTTP protocol allows you to retrieve hypertext-based documents from the server side. Increasingly, the information being downloaded from the server side is encoded in one of the standard encoding formats like JSON or XML. And in order to be able to talk to a server, you have the support from various HTTP actions or what we refer to as HTTP verbs, the head, get, post, put, delete, trace, options, and connect. We will see in particular the get, put, post, and delete verbs in more detail when we examine the REST API protocol a little bit later. How does the HTTP protocol work? In the HTTP protocol, you are sending a request from your client application to the server, and this is encoded in the form of an HTTP request message. The request message typically carries a URL in the request message indicating what is it that you want the server side to send it to you. And this is typically a get message if you want data to be downloaded from the server side, and you will also specify which particular server you are communicating with. When the server receives your request, the server will retrieve the data from its data storage, typically a database on the server side, and then package this data in an appropriate format and send the data back to you on your client side. If you are obtaining standard HTML, CSS, and JavaScript code from the server side, then your browser is able to render this. But with applications like Angular, you are primarily connecting to the server and then retrieving data in the form of either JSON or XML most of the time, except for the initial download of all the resources that are required for your application to be executed within your browser. So, as we saw earlier, the HTTP application requires messages to be sent between the client and the server. A request message is typically sent from the client to the server and the request message consists of a request line plus a bunch of headers where you supply additional information to qualify the request. We will see the use of various headers and settings in the headers as we go through some of the exercises in this particular module. The request line and headers are separated from the body of the request message by one blank line. The body of the message may contain additional data especially if your client is sending data over to the server side. For example, when you submit a form, the information within the form is encoded into a JSON format and then sent over to the server side from the client side. So that would be done using either post or a put message. Looking at the little more details of the HTTP request message, the typical request message in the request line will contain the method which is either get, put, post, delete, or some of the other verbs that you have seen earlier, and then followed by the URL and the version of the HTTP protocol that you're using for communicating from the client to the server side. The header field usually contains a Header Field Name: and the value for that header field, and the body contents, as I mentioned, could be encoded in either JSON or XML format. Here is an example of a typical HTTP request message that may be sent to the server from the client. So in this particular request message, we are asking the server to return the index.HTML page from the server side to the client side so that it can be rendered in the browser on the client site. A request like this would typically have an empty body in the request message. Most of the information will be encoded in the request line plus the headers of the request message. When the client sends the request to the server, the server will process the request and then send back a reply to the client side. The reply message is organized into, again, three parts: a status line with some information about how the request has been processed and what is being sent back to the plant is stored, the headers will contain additional details of what is contained in the response message, and then followed by a blank line and then the actual body of the message. An example of what would be typically contained in an HTTP response message. In this case, this response message is coming back with a 200 which is a status code of the message. If you see a 200 in the request line as a status code, it means that your request was successful and the server is able to return the data that you have requested from the server side. And then, the header will contain additional directions to the client side including information about how the actual body of the message is encoded. Then, if you have requested the index.HTML page, the body of the message will contain the HTML code for the index.HTML page, as you'll see in this example here. One of the pieces of information in the status line that I referred to as the status code, if the server is able to process your request correctly, it'll send back a reply with a status code of 200, meaning everything is okay on the server side and the server side is returning the data correctly. If the server is unable to process the request for whatever reason, then that information will be encoded in the status code in the status line of the reply message. The various status codes, typically, that you will encounter when you receive a reply from the server side include a 201 which means that when you tried to create an object on the server side, it had been successful created, or a 301 which means that whatever you are requesting has moved permanently to a new location and the URL of the new location of that resource will be returned to your client side; 400s and 500s typically indicate that there was some problem on the server side. A 404 is something that you often encounter when you request for something that doesn't exist on the server side. Similarly, 500 means that the server is just giving up. It is unable to process your request and then sends back an internal server error. These are two common error codes that you will encounter. The remaining ones have specific meaning as listed in this table here. There are more than the status codes that I give you in this table but these are some of the most common status codes that you will encounter in a reply message coming from the server side. Another point that I mentioned is the fact that the server may encode the data in a specific format like XML, or Extended Markup Language, or JSON, the JavaScript Object Notation format. Now typically, in this particular course, we will be dealing with data that is encoded mainly in JSON. Most client-side applications including mobile applications these days typically communicate with the server and the data exchange format is JSON by default and in most cases. What is the reason? I will spend a few minutes explaining to you about JSON. The JavaScript Object Notation or JSON is a light way to data interchange format. The reason the JSON data format is specifically of interest to us in this course is because the JavaScript Object Notation, as the name implies, very easily maps into a JavaScript object that you use within your JavaScript code. So converting a JavaScript object into JSON notation and vice versa is very straightforward. The JSON notation is what we call as a self-describing and very easy to understand notation. In the JavaScript Object Notation format, the data data is structured in a very clean, specified manner. This is structured as a collection of name value pairs and this is structured as an ordered list of values. You can see an example of this on the right-hand side here. Now, you see why the data is structured that way and you also realize that it is very easy to be able to deal with that data within your JavaScript code in your application. With this, I complete a quick overview of networking essentials. We'll now move on to an exercise where we will set up a rudimentary server that will serve up some data that we can connect to from our application and then exchange data with a server. Now, we will develop a full-fledged server in one of the later courses, the NodeJS and Server-side Development course that would come as a last course in this specialization.