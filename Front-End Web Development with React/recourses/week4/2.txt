As we have learned in the previous lecture, we can split our Reducer into multiple simpler Reducers, and then combine them together to form the overall Reducer that manages the global state. Now, in this exercise, we will take the simple Reducer that we implemented for our Redux, and then split it into multiple Reducers. Now, as we develop our application, you will begin to see the advantage of having multiple Reducers that manage parts of the state, and independently, and they can only concentrate on how that part of the state is updated. And then, by combining them together, you can easily see how the overall global state can be managed. To enable us to split the Reducer into multiple Reducers, and then combine them together. Taking a look at the initialState here, what we realize is that it is easy to split our Reducer each into four different Reducers managing each of these parts of our state. So, you have dishes, comments, promotions, and leaders. So, I'm going to create four different Reducers managing each one of these parts, and then combine them together in our Redux. So, to do that first, we will go to the Redux folder, and then create a new file named dishes.js. And from the reducer.js file, I'm going to cut this, and then move it into the dishes.js file. Now, from this dishes.js file, I'm going to export a function here. The Reducer function which manages only the dishes so, we'll see. Again, when you implement the Reducer function it takes the state, and action as the two parameters. So, they'll specify this as state, and action, and this will return. As you see, I will implement this as the switch, and then we'll say action.type. So, it will switch on the action.type as we learnt in the lecture earlier. Now, at this moment, we haven't implemented any actions. So, we will only have the default for us. And as the default, all that you do is return the state, and modify it from this. So, this is the default implementation for our dishes.js file. So, as you can see, what we are doing here is that if the state is undefined you give the initial, or the default value as dishes that we have just imported here, and then you're returning the state. So, the default return is dishes as it is. If you're not modifying that in any way, then that's all that is required to be returned from the dishes.js file. So, we have introduced our first simpler Reducer. Let's go ahead, and introduce another Reducer called as comments.js as you would expect. And to comment.js, I'm just going to cut this out from Reducer.js file, move it in here. And then, from the dishes.js file, because the structure is going to be exactly the same as before. So, I'm just going to copy the dishes from dishes.js. And then I name this as comments. And then so, the state will return comments, and action, and the rest of it exactly the same. So, now we have the comments reducer here. Similarly, let's introduce the promotions reducer here. Again, going to reducers.js, will cut this out, and then move this into promotions, and then we'll simply copy this part, because the structure is going to be exactly the same of the code here. And then we'll say export promotions, and the state is promotions actions. And then finally of course, the fourth part which is the leaders.js file. And in the leaders.js file, they'll cut the leaders import from reducer.js, move it into the leaders.js file. Let's again, since the structure is the same, let me copy this into leaders.js file, and then we'll return leaders from here. And so, the state will be leaders. So, now you see how each of these simpler Reducer functions simply return the leaders, the promotions part of the state, the comment part of the state, and the dishes part of the state. Now coming back to the reducer.js. Now, since all the functionality of this Reducer has been moved away into the four different files, there is no more need for reducer.js file anyway. So, I can simply go ahead, and then delete the reducer.js file, because that is no longer required here. Because these four reducer functions that we have implemented take care of the overall state. Now that we have implemented this four separately, we'll go into the ConfigureStore, and in the ConfigureStore, we will originally importing the Reducer from the Reducer. Now the initialState is no longer required, because that is already initialized by our application. So, I'm going to cut that out, and then we'll first turn that into seeing dishes from dishes, because that's what we have divided over Reducer into let's import similarly the remaining three. So, we'll import comments from comments, and then promotions from promotions, and then leaders from leaders here. Now, once we import this, now you realize that your Reducer has been split into its parts. So, how do we combine them together. To combine them together, Redux provides us with a method called as combineReducers. So, we will import the combineReducers in here, and then when we create the store here. Instead of just doing Reducer initialState, we will say, combineReducers. And inside this combineReducers, we will specify how exactly to combine the various Reducers that we have defined here. The four simpler Reducers that we have defined here. So, to compose the overall global state, we have to map these Reducers into each one of the four properties there. So, they will say, dishes is managed by dishes, then comments by comments, promotions with the small p is managed by promotions, and leaders by leaders here. So, this is how the combineReducers will take the Reducer mapping object, and then that will map the overall smaller, simpler Reducer functions into various properties in the whole ground. So, now we will see that we have recomposed the global state for our application as shown here. And that's about it. So, our application is now ready with the simpler Reducer functions that we have implemented by splitting them into four simpler Reducer functions, and then combining them back into the overall state of our application by using combineReducers. And with this, we have completed the changes. Let's save the changes and then go and take a look at our application. Going to our application, our application will behave exactly as before. There's no change in the way the application works, because we haven't changed anything about the functionality of the application, we have just rearranged the Redux to use combineReducer. So, all the parts that we've implemented are all existing assets before, and so no change should be noticed in the functioning of your application itself. With this they complete this exercise. This is a good time for you to do a good comic with the message combining Reducers.