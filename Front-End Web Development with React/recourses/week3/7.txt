In the previous lecture, we saw a brief introduction to the Flux architecture, as a way of organizing our react application. We saw how we can move the state out of the components, and into a separate set of stores, which is supported through the Flux architecture approach. Now, Redux is one such approach that has been suggested as a way of organizing your react application. Redux derives a lot of its ideas also from the Flux architecture but it is a realization of the Flux architecture. Now, let's talk about Redux, and how we can make use of it with a react application. Now, Redux was proposed by Dan Abramov. In one of his talks, in Riyadh, Europe, a project where he was trying to demonstrate ideas about time-travel debugging, and so on, and so he created this framework to demonstrate his idea, and then it ended up being very popular, as a Flux-like approach for a react application. Let's examine a little more details about Redux in this lecture, and then over the next subsequent lessons, we will see how we can integrate Redux as part of our react application. So, what exactly is Redux?. Now, as we discussed in the previous lecture, you want to be able to have a place where you will store your state of your application, and have a consistent way of being able to access the state. Especially, when your react application becomes huge with several hundreds of components, with lots of interactions going on between them, you need a consistent way of being able to support the state for your application, and be able to modify the state from any part of your react application, and the changes being reflected or accessible from any other component in your react application. Now, the hierarchical approach that we have seen with our react application so far doesn't scale very well in these circumstances. So that's why you want to be able to have state container, which is predictable and easy to use. So that is the reason for developing Redux. Again, Redux is a realization of Flux-like architecture. Redux also improves up on certain issues that we notice with Flux architecture. So, you would see this as yet another approach which draws its ideas from Flux, and then the Elm functional programming approach, and also the immutable.js, which supports immutable JavaScript objects and so on. So again, inspired by all these, Redux was suggested as an approach for structuring your react application. Now, Redux itself has nothing to do with react per say, you could use the Redux approach even with an angular application, or with JS application, or backbone or ember or whatever. But, it just so happened that Redux was adopted very well by the react community and hence when your hear about Redux, you often think in terms of react. But these two are two separate entities. Now, as I said, Redux being very effectively leveraged by the react community, and hence, the two often go together in many of their documentations or many of the blog posts and so on that you'll see online. But Redux has nothing to do with react per se. So this is something that I want to make it very clear to you at the outset itself. Redux is a general approach that supports a way of managing store, unidirectional flow that is characteristic of the Flux architecture and much more. Now, given this introduction to Redux, the reason for adopting something like Redux is that it makes state mutations predictable. Also, Redux supports things like time-travel debugging and so on, which I will illustrate briefly as we go through the exercises, we will see that there is a consistent way and you can even observe how your state is being changed and there is a consistent way that you modify the state and so on. Because when you adopt the Redux architecture for your react application, it becomes even more easier to handle the states. Now, let's examine Redux in a little more detail in this lecture, and then we will move on to the exercise where we will update our application to integrate Redux into our react application. Now, at the outset, let me outline the three main principles of Redux as stated by Dan Abramov. The first principle that he states is that in Redux there is a single source of truth or there is a single state object tree within a single store. The Flux architecture allows you to have multiple stores that need to be coordinated together by the dispatcher, and when it dispatches the actions to the stores, all these stores need to update themselves. In Redux, there is a single store. The single store has a single state object tree within the single store, and so that becomes the single source of truth for your applications, be it react or angular, wherever you apply Redux. So, that's the first principle that they start with. Second, the state is read only. Meaning that you can only do gets on the states. So, only getter operation source supporter of state by the store. Any changes to the store should be done only through actions. Again, this comes back from the Flux approach that we have seen. The uni-directional data flow approach that we have just seen in the previous lecture. The third part is that any changes that you make to the state are made by only pure functions, what in Redux terms are called as reducer functions. Now, what does this pure function do? The pure function takes the previous state of your application, and the action that is specified, and given the previous state and the actual that is specified, it'll generate the new state for the application. When the next state or the new state is returned, this new state will not be a modification of the previous step. Previous state will remain as such. But the pure function will return in new state, which is derived from the previous state, but then it'll create a new state in return. So, there is no mutation of the previous state. Now, within your store, you will store this next step. So your next state of your application will mutate to the next state. Again, because of the use of the pure functions, the immutability of the state is preserved. So, that's the idea behind how Redux approaches the three principles behind Redux. Now, how is this actually achieved in practice? Now, this is where we look at the Redux structure and how you implement the Redux approach for our react application in bit more detail. Now, why do we make use of Redux? The Redux approach which uses a single store and a single state tree makes it easy for us to implement a few things. Logging of changes to the state is very easy. Now, as you saw because we use pure functions, the next state is always generated from the previous state, but the next state does not change the previous state directly. The pure function returns the next state. So, you can track all the states of your application as they change, and you can log the changes. If we're handling become very easy, we will see how we can do that in one of the later lessons. Then, you also have the facility for doing, undo and redo approaches. So, this is what allows you to be able to undo operations and then look back at what has changed. So for example, if you encounter a bug, you can walk backwards and then check through the state changes to see how you arrived at the current state and if there was something that was wrong in the way the state was changed. So that allows you to do undo operations so if you don't want to process the change that you've done, it is very easy to support undo. It comes naturally in react as we will see there. State persistence comes in, and then also time-travel debugging also comes to your aid. Again, we'll look at these two in a bit more detail in the lessons that follow later on in this course. How exactly do you structure in Redux architecture? Now this is where you'll see the Redux architecture being defined again. You see the return of some of those concepts from Flux. As I said, Redux is itself influenced by Flux, and so the uni-directional data flow approach that Flux adopts is also adopted by Redux. So, some people tend to view Redux as an implementation of Flux. But again, Dan Abramov himself, doesn't view it as such. I mean, when you look at some of the explanation in the documentation of Redux, this is made more clear. Redux could be viewed as a derivative from Flux if you wish to do so because you will see a lot of those concepts returning in Redux. Now, in Redux, how is this organized? In Redux, the state itself is in your store, so there is a single store, and there is a single state tree that tracks the state of your application. Cascade itself can be only modified by using reducer functions. Now, we'll look at reducer functions in a bit more detail. These reducer functions are pure functions. The reducer function takes the current state or the previous state of your application, it receives the action that comes in through the dispatch. Now, here in Redux, the dispatch also is considered part of the store. So, your action is dispatched into your store. The store then uses the dispatch of the previous state and then sends this as input to the Reducer functions. The Reducer function will return the state from these two inputs, and the next state is then stored in your store. And so, that is how your store gets updated. The views themselves are watching the store and any changes to the state will result in the emission of the change to the view and when the view notices the change, the view will go and get the state. And then, if you may generate an action in response to the user's interaction with the user interface component and so on. So, that's the approach that Redux states. Now, let's examine a few of these parts in a bit more detail. Now, the action, the action creator, and action types and so on, I will defer that to the first lecture in the next module. But for the moment, let's look at the state reducer in a little more detail in this lecture. So now, let's examine a few of the Redux concepts now. The first place maybe we'll start is the state. The state in Redux is stored as a plain JavaScript objects, JavaScript object tree that we store there. And in action is also a plain JavaScript object with a type field. The type field specifies what kind of action that is and also it carries some payload. That's the term that they use, payload. The payload specifies what changes need to be initiated. Now, you create an action using an action creator as we will see in the next module. So, that's what the action supports for you. And the third piece of the puzzle is the reducer. What is a reducer? The reducer as you see is a pure function that takes the current state and action and generate the next stage of your application. Now, the update to the data is done immutably. Immutably means that the previous state itself is not modified in any way. Now, immutability is a concept that you'll need to study in more detail to understand what immutable means. In immutability, if you have an object you won't change that directly, but instead you derive a new object by copying the previous object and then generate a new object as a copy with the modification applied. You generate a whole new object from the previous object. That is what the preserving the immutability of the objects means. Now again, in the exercises when we actually do this, we will practically understand what this means. Specially, when I implement the reducers functions, I will highlight the plight on how you are not changing the previous state and how you are generating a new object from the previous object by applying the changes to a copy of the previous object. So, that's what immutability in a nutshell means. Again, going into a deep discussion on immutability or why it is necessary and so on is beyond the scope of this course, but I've given you links to the immutability concept and you can study more about that on your own. Okay, what exactly is the Redux store? As you saw in the diagram earlier, the Redux store contains the state and the reducer functions and the dispatch. So, the Redux store itself holds the current state values. So, that is where it has been kept as a pure JavaScript object. And this Redux store is created in your code using this createStore() method call that we will do. So, that's how you end up initializing Redux store. This Redux store also supplies three methods. It supplies a dispatch method. Now, the dispatch method is where you will supply the action object and then specify what changes you want to make to the state. Now, getting the state is supported through the getState method. And you can subscribe to the state. So, it accepts the callback function that will be run every time an action is dispatched. So, the dispatching of an action will result in an update to the state. And then, that you can subscribe to the changes and then watch the changes. And you can use getState to get the updated state from your store. Now, we'll see how react and Redux get integrated together using a NPR model called react-Redux. So, coming to this question of how do you integrate react with Redux. Now, you use the react-Redux package for binding your react to your Redux application. So, you will take your react component, what we call as the component that previously was holding the state. When you move the state into the Redux store, you want your react component to be able to obtain the copy of the state. So, within our example application we'll take our main component and tie it to the Redux store through the connect method that is made available react-Redux package. So, this will enable you to connect your component to the Redux store. What does connect provide for you? The connect provides a wrapper container component. Remember we talked about container components in the previous module. So, when you use connect, the connect automatically generates container component around the component within which you apply this. And then, that allows you to connect to the Redux store. And then the state can be obtained from the Redux store within your application. Now, in your react application, to make that store available to all the components within your react application, you surround your application root by the provider component that is available from react-Redux. The provider itself takes the store as an attribute, and then it makes the store available to all the connected components. Now, this may not make much sense to you at this moment, but in the very next exercise we will actually apply this. So, when I apply these techniques for my react application, it'll become more clearer to you what I am talking about. How do I connect my react component to the Redux store? How do we synchronize the state changes? How do we obtain any state modifications to automatically update the state in our react application and thereby, result in rendering of our views and so on. Then you apply that connect function to your react component. The connect function also takes two optional arguments called mapStateToProps and mapDispatchToProps. The mapStateToProps is called every time store state changes. So, as you recall, the Redux store, whenever it detects a state change that will emit the change, and then that will result in your component need to go back and pull in the state from the Redux store. Now, because you are connecting your react component to the Redux store, so to this connect, when you supply this mapStateToProps, the state here means the Redux state. So, that state will be mapped into the props of your component. And so, the state information becomes available to props in your react component, and those props can then be parsed down to your children as required in your application. Now similarly, previously we've been implementing all state changes by implementing functions within the main component which will be called by your child components. Now, changes to the state will have to be dispatched to the Redux store. Now, this is facilitated through this mapDispatchToProps. Again, when we do actions and action creators and so on in the first lesson of the next module, we'll apply the mapDispatchToProps and then map our actions, mapping them to dispatch to our Redux store. Now, we'll come back to see this in a bit more detail in that lesson. Now, with this quick understanding of react and how react can be upgraded with the use of the Redux, let's move on to the exercise where we will update our react application to make use of Redux.